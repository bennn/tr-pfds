\chapter{Evaluation of Typed Racket}
%This project involved writing 5300 lines of Typed Racket code, including
%1300 lines of tests, almost all written by the first author, who had
%little previous experience with Typed Racket.  This allows us to report
%on the experience of using Typed Racket for a programmer coming from
%other languages.

%The philosophy of Typed Racket is \emph{easy porting of untyped code to
%typed sister languages}. As a part of this thesis,
This chapter reports on my experience with Typed Racket's type system in
the context of purely functional data structures and contrasts it with
other statically typed functional languages. The data structures
developed to support this thesis were originally developed in statically
typed functional programming languages with different type
systems. Thus, eventually the suitability of Typed Racket for
implementing purely functional data structures serves as a valuable test
case for evaluating Typed Racket's type system against other type
systems.
%Also, the chapter reports on the experience of
%using Typed Racket and the support Typed Racket provides to the
%developer.

\section{Benefits of Typed Racket}

\subsection*{Data Structures from Other Languages}
The purpose of Typed Racket is to facilitate \emph{the gradual porting
of untyped code to typed sister languages}. Typed Racket was developed
as a sister language of Racket and support the Racket idioms. However,
all the data structures developed to support this thesis, were
originally developed in other statically typed functional languages such
as ML and Haskell. These languages have different type system and
support different idioms than Racket.

The following examples highlight the similarities between Typed Racket
and ML code by comparing the data definitions and function definitions
in these two languages. Although, the Typed Racket's type system is
different from other statically typed languages, the definitions in
these statically typed languages have a straightforward mapping to Typed
Racket.

Figure~\ref{ml:1}~and~\ref{ml:2} show the Banker's Queue and Physicist's
Queue structure definitions in Typed Racket and ML respectively.

%\begin{mlexample}
%  \begin{schemedisplay}
%    (struct: (alpha) Queue
%      ([lenf  : Integer]
%       [front : (Stream alpha)]
%       [lenr  : Integer]
%       [rear  : (Stream alpha)]))
% 
% 
%    type 'alpha Queue = int * 'alpha Stream * int * 'alpha Stream
% 
%  \end{schemedisplay}
%  \label{ml:1}
%\end{mlexample}

\begin{figure*}[ht]
  \begin{minipage}{2in}
    \begin{adjustwidth}{5em}{}
      \begin{tabular}{|l|l|}
        \hline        
        \scheme|(struct: (alpha) Queue|        & \\
        ~~~\scheme|([lenf  : Integer]|         & \scheme|type 'alpha Queue = int|\\            
        ~~~~~\scheme|[front : (Stream alpha)]| & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* 'alpha Stream|\\               
        ~~~~~\scheme|[lenr  : Integer]|        & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* int| \\
        ~~~~~\scheme|[rear  : (Stream alpha)]| & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* 'alpha Stream|\\              
        \hline
      \end{tabular}
    \end{adjustwidth}
  \end{minipage}
  \caption{Typed Racket and ML Definition: Banker's Queue}
  \label{ml:1}
\end{figure*}

%~~\\

\begin{figure*}[ht]
  \begin{minipage}{2in}
    \begin{adjustwidth}{3em}{}
      \begin{tabular}{|l|l|}
        \hline        
        \scheme|(struct: (alpha) Queue|                  & \\
        ~~~\scheme|([pref  : (Listof alpha)]|            & \scheme|type 'alpha Queue = 'alpha list|\\            
        ~~~~~\scheme|[lenf  : Integer]|                  & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* int|\\               
        ~~~~~\scheme|[front : (Promise (Listof alpha))]| & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* 'alpha list susp| \\
        ~~~~~\scheme|[lenr  : Integer] |                 & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* int|\\              
        ~~~~~\scheme|[rear  : (Listof alpha)]))|         & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* 'alpha list|\\      
        \hline
      \end{tabular}
    \end{adjustwidth}
  \end{minipage}
  \caption{Typed Racket and ML Definition: Physicist's Queue}
  \label{ml:2}
\end{figure*}

%The following example shows the  structure definitions
%in Typed Racket and ML.

%\begin{mlexample}
%  \begin{minipage}{2in}
%    \begin{tabular}{l|l}
% 
%\scheme|(struct: (alpha) Queue|                  & \\
%~~~\scheme|([pref  : (Listof alpha)]|            & \\
%~~~~~\scheme|[lenf  : Integer]|                  & \scheme|type 'alpha Queue = 'alpha list|\\                                
%~~~~~\scheme|[front : (Promise (Listof alpha))]| & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* int * 'alpha list susp|\\
%~~~~~\scheme|[lenr  : Integer] |                 & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* int * 'alpha list| \\ 
%~~~~~\scheme|[rear  : (Listof alpha)]))|         & \\      
% 
% 
%    \end{tabular}
%  \end{minipage}
%  \label{ml:2}
%\end{mlexample}

%\scheme|(struct: (alpha) Queue|                  & \scheme|type 'alpha Queue =| \\ 
%~~~\scheme|([pref  : (Listof alpha)]|            & ~~~~~~~~~~~~~~~~~~~~~~~~~~~\scheme|'alpha list|\\
%~~~~~\scheme|[lenf  : Integer]|                  & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* 'alpha list susp| \\ 
%~~~~~\scheme|[front : (Promise (Listof alpha))]| & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* int|\\ 
%~~~~~\scheme|[lenr  : Integer] |                 & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* int|\\ 
%~~~~~\scheme|[rear  : (Listof alpha)]))|         & ~~~~~~~~~~~~~~~~~~~~~~~~\scheme|* 'alpha list|\\

%\vspace{5em}
~~\\

The \emph{tagged unions} provided by languages like ML and Haskell can be
emulated using the union operator \scheme|U| in Typed Racket. Consider
the definitions of a binary tree in Figure~\ref{ml:3}.
~~\\
%\begin{mlexample}
%  \begin{schemedisplay}
% 
% (define-type (Tree alpha) (U Leaf (Node alpha)))
% 
% (struct: Leaf ())
% 
% (struct: (alpha) Node
%   ([data : alpha]
%    [left   : (Tree alpha)]
%    [right : (Tree alpha)]))
% 
% 
%   
% datatype 'alpha tree = Node of {data : 'alpha, left : 'alpha tree, right : 'alpha tree}
%                      |  Leaf;
% 
%  \end{schemedisplay}
%  \label{ml:3}
%\end{mlexample}

\begin{figure*}[ht]
  \begin{minipage}{2in}
    \begin{adjustwidth}{-1em}{}
      \begin{tabular}{|l|l|}
        \hline        
        \scheme|(define-type (Tree alpha) (U Leaf (Node alpha)))|                  & \\
                                               & \\            
        \scheme|(struct: Leaf ())|             & \scheme|datatype 'alpha tree = Node of {data : 'alpha, |\\                          
                                             & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\scheme|left|~~~\scheme|: 'alpha tree,|\\
        \scheme|(struct: (alpha) Node|         & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\scheme|right : 'alpha tree}|\\
        ~~~~\scheme|([data : alpha]|           & ~~~~~~~~~~~~~~~~~~~~~~~~~~~|~\scheme|Leaf;|\\
        ~~~~~\scheme|[left|~~~~\scheme| : (Tree alpha)]|  & \\
        ~~~~~\scheme|[right|~\scheme| : (Tree alpha)]))| & \\
        \hline
      \end{tabular}
    \end{adjustwidth}
  \end{minipage}
  \caption{Typed Racket and ML Definition: Binary Tree}
  \label{ml:3}
\end{figure*}

Although tagged unions are not a part of Typed Racket, emulating ML
definitions using tagged unions is simple and straightforward.

%If the given heaps use different comparison functions, .

%that require a comparison function Typed Racket does not supp

\clearpage

Pattern matching is a widely used technique in statically typed
functional languages like ML and Haskell. Figure~\ref{pm:1} shows the ML
function definition to balance a Red-Black Tree \citep{oka-red-black}.

%            - fun list_length [] = 0
%                | list_length (f::r) = 1 + list_length r;
% 
%            = val list_length = fn : 'alpha list -> int

\begin{figure*}[ht]
  \begin{adjustwidth}{-1.5em}{}
  \begin{plain}
  \begin{schemedisplay}
 fun balance T (B, T(R, T(R, a, x, b), y, c), z, d) = T(R, T(B, a, x, b), y, T(B, c, z, d))
   | balance T (B, T(R, a, x, T(R, b, y, c)), z, d) = T(R, T(B, a, x, b), y, T(B, c, z, d))
   | balance T (B, a, x, T(R, T(R, b, y, c), z, d)) = T(R, T(B, a, x, b), y, T(B, c, z, d))
   | balance T (B, a, x, T(R, b, y, T(R, c, z, d))) = T(R, T(B, a, x, b), y, T(B, c, z, d))
   | balance T body = T body
  \end{schemedisplay}
  \end{plain}
  \caption{Pattern Matching in ML}
  \label{pm:1}
  \end{adjustwidth}
\end{figure*}
\noindent
\scheme|balance| uses the pattern matching technique. The function takes
a tree as input and returns a tree. The function definition has five
clauses. The structure of the input tree is matched against the left
side of the clauses and upon a match, the right side is returned.

Typed Racket provides a sophisticated match construct for pattern
matching known as \scheme|match|. It supports a wide variety of useful
pattern-matching forms and makes porting code from ML to Typed Racket
straightforward. Figure~\ref{pm:2} shows the Typed Racket definition of
\scheme|balance| using \scheme|match|. It is similar to the ML
definition of \scheme|balance|.

%   (: list_length : (All (alpha) (Listof alpha) -> Natural))
%   (define (list_length l)
%     (match l
%       ['() 0]
%       [(list f r ...) (+ 1 (list_length r))]))


\begin{figure*}[ht]
  \begin{plain}
 \begin{schemedisplay}

(: balance : (All (alpha) ((Tree alpha) -> (Tree alpha))))
(define (balance tree)
  (match tree
    [(T B (T R (T R a x b) y c) z d)   (T R (T B a x b) y (T B c z d))]
    [(T B (T R a x (T R b y c)) z d)   (T R (T B a x b) y (T B c z d))]
    [(T B a x (T R (T R b y c) z d))   (T R (T B a x b) y (T B c z d))]
    [(T B a x (T R b y (T R c z d)))   (T R (T B a x b) y (T B c z d))]
    [else tree]))

 \end{schemedisplay}
  \end{plain}
  \caption{Pattern Matching in Typed Racket}
  \label{pm:2}
\end{figure*}

\subsection*{Other Features of Typed Racket}
%Several other features of Typed Racket makes programming in Typed Racket
%supported the development of this library. First,

The type error messages in Typed Racket are clear and easy to
understand. The type checker highlights precise locations that are
responsible for type errors. This makes it very easy to debug the type
errors.

%Second, Typed Racket's syntax is very intuitive, using the infix
%operator \scheme|->| for the type of a function. The Kleene star
%\scheme|*| is used to indicate zero or more elements for rest
%arguments. \scheme|All| is the type constructor used by the polymorphic
%functions, and so on.

Typed Racket comes with a unit testing framework, which makes it simple
to write tests. Figure~\ref{ut:1} shows the use of Typed Racket's
testing framework. The \scheme|check-expect| form takes the actual and
expected value, and compares them, printing a message at the end
summarizing the results of all tests.

\begin{figure*}
\begin{plain}
  \begin{schemedisplay}
    langtr
    (require typed/test-engine/racket-tests)
    (require "bankers-queue.rkt")
    (check-expect (head (queue 4 5 2 3)) 4)
    (check-expect (tail (queue 4 5 2 3))
                  (queue 5 2 3))

  \end{schemedisplay}
\end{plain}
\caption{Examples of Unit Tests}
\label{ut:1}
\end{figure*}


The introductory and reference manuals of Racket in general and Typed
Racket in particular are comprehensive and quite easy to follow and
understand.

\section{Disadvantages of Typed Racket}

Even though my overall experience with Typed Racket is positive, there
are several negative aspects to programming with Typed Racket.

\subsection*{Polymorphic Recursion}
Most significantly for this work, Typed Racket does not support
polymorphic non-uniform recursive datatype definitions. Number of data
structures by \citet{oka} extensively use polymorphic recursion.
Because of this limitation, many definitions had to be first converted
to uniform recursive datatypes before being implemented. For instance,
consider the definition of \scheme|Seq| structure in
Structure~\ref{pstruct:1}. This definition is not allowed by Typed
Racket.

\begin{pstructure}
  \begin{schemedisplay}
    langtr

    (struct: (alpha) Seq
      ([elem   : alpha]
       [recur : (Seq (Pair A A))]))
  \end{schemedisplay}
  \label{pstruct:1}
\end{pstructure}

The definition must be converted not to use polymorphic recursion.
Structure~\ref{pstruct:2} shows the converted \scheme|Seq| structure.

\begin{pstructure}
  \begin{schemedisplay}
    langtr

    (struct: (alpha) Elem ([elem : alpha]))
    
    (struct: (alpha) Pare 
      ([pair : (Pair (EP alpha) (EP alpha))]))
    
    (define-type (EP alpha) (U (Elem alpha) (Pare alpha)))
    
    (struct: (alpha) Seq
      ([elem   : (EP alpha)]
       [recur : (Seq alpha)]))
  \end{schemedisplay}
  \label{pstruct:2}
\end{pstructure}

Unfortunately, this translation introduces the possibility of illegal
states that the type checker is unable to rule out.
%We hope to support
%polymorphic recursion in a future version of Typed Racket.

%\subsection*{Functors}
%As mentioned earlier, a heap is a specialized tree-based data structure
%that satisfies some kind of heap property and are said to be
%heap-ordered. For heap-ordering the elements, heaps require a function
%that can compare the elements of the heap. In this implementation, a
%comparison function is supplied when a new data structure is created,
%and every structure comes with its own comparison function. This
%approach is flexible, but causes a problem for the function
%\scheme|merge| that combines two heaps. %Consider the expression in.
% 
%\begin{defmodule}
%\begin{schemedisplay}
% 
%  langtr
%  
%  (merge (heap > 5 6 7 8) (heap < 1 2 3 4))
% 
%\end{schemedisplay}
%\label{e:4}
%\end{defmodule}
% 
%In the expression in Example~\ref{e:4}, \scheme|merge| raises the
%question about which comparison function should the resulting structure
%keep since the input heaps use different comparison functions. The ML
%implementations uses \emph{functors} to fix the comparison function when
%the structure is created and avoid this problem. Typed Racket does not
%have a mechanism similar to \emph{functors}. So the Typed Racket
%implementation of these structures expect a comparison function when the
%structure is created. And in functions like \scheme|merge|, the
%resulting heap will have the comparison function from the first heap
%(\scheme|>| in the above example) given to \scheme|merge|.

\subsection*{Variable-arity Functions}

Consider the two \scheme|foldr| expressions in Figure~\ref{fold:1}. The
list in first expression is the the built-in \scheme|cons|-list and the
the list in the second expression is a VList from my purely functional
data structure library. Although the two expressions are identical, the
results produced by the two expressions are different. The results are
\scheme|2| and \scheme|-14| respectively.

\begin{figure*}
\begin{plain}
\begin{schemedisplay}
  langtr
  
  (foldr - 1 (list 1 2 3 4 5))

  (require (prefix-in v: (planet krhari/pfds:1:5/vlist)))
  (v:foldr - 1 (v:list 1 2 3 4 5))
\end{schemedisplay}
\end{plain}
\caption{Variable-arity Functions}
\label{fold:1}
\end{figure*}

The difference between the two results is because it is currently not
possible to correctly type Racket functions such as \scheme|foldr| and
\scheme|foldl| because of the limitations of Typed Racket's handling of
variable-arity functions \citep{stf-esop}.


\subsection*{User-Defined Data Types}
Although Racket supports extension of the behavior of primitive
operations such as printing and equality on user-defined data types,
Typed Racket currently does not support this. Thus, it is not possible
to compare any of our data structures accurately using \scheme|equal?|,
and they are printed opaquely.

Typed Racket allows programmers to name arbitrary type expressions with
the \scheme|define-type| form.  However, the type printer does not take
into account definitions of polymorphic type aliases when printing
types, leading to the internal implementations of some types being
exposed. This makes the printing of types confusingly long and difficult
to understand, especially in error messages.

\subsection*{Racket's Numeric Tower}
Typed Racket provides precise types for Racket's numeric tower. Because
of the precise numeric types, the type for functions like \scheme|+| and
\scheme|-| have several cases for each type in the numeric
hierarchy. The type errors involving these functions contain the whole
numeric type hierarchy and leads to illegible error messages. Consider

\begin{center}
  \scheme|(foldl + 0 (list 1 "2"))|
\end{center}

In the above expression, since the input list contains a string and the
function \scheme|+| is not defined for strings, Typed Racket,
appropriately, signals a type error. But the error message is illegible.
Figure~\ref{er:1} shows the error message displayed by Typed Racket.
\def\keywordfont#1{{\it#1}}
\begin{figure*}
\begin{plain}
\begin{schemedisplay}

Type Checker: Polymorphic function foldl could not be applied to arguments:
Domains: (a b -> b) b (Listof a)
         (a b c -> c) c (Listof a) (Listof b)
         (a b c d -> d) d (Listof a) (Listof b) (Listof d)
Arguments:
(case-lambda
  (Exact-Positive-Integer Exact-Nonnegative-Integer * -> Exact-Positive-Integer)
  (Exact-Nonnegative-Integer Exact-Positive-Integer
   Exact-Nonnegative-Integer * -> Exact-Positive-Integer)
  (Exact-Nonnegative-Integer * -> Exact-Nonnegative-Integer)
  (Integer * -> Integer)
  (Exact-Rational * -> Exact-Rational)
  (Nonnegative-Float * -> Nonnegative-Float)
  (Float * -> Float)
  ((U Nonnegative-Float Exact-Positive-Integer Zero) * -> Nonnegative-Float)
  (Float Real * -> Float)
  (Real Float Real * -> Float)
  (Inexact-Real * -> Inexact-Real)
  (Real * -> Real)
  ((U Float-Complex Inexact-Real Exact-Rational) * -> Float-Complex)
  (Float-Complex Complex * -> Float-Complex)
  (Complex Float-Complex Complex * -> Float-Complex)
  (Complex * -> Complex)) Zero (List Positive-Fixnum String)
\end{schemedisplay}
\end{plain}
\caption{Type Error: \emph{foldl}}
\label{er:1}
\end{figure*}

%(case-lambda
%  (Positive-Byte Positive-Byte -> Positive-Index)
%  (Byte Byte -> Index)
%(Exact-Positive-Integer Exact-Nonnegative-Integer * -> Exact-Positive-Integer)
%(Exact-Nonnegative-Integer Exact-Positive-Integer Exact-Nonnegative-Integer * -> Exact-Positive-Integer)
%(Exact-Nonnegative-Integer * -> Exact-Nonnegative-Integer)
%(Integer * -> Integer)
%(Exact-Rational * -> Exact-Rational)
%(Nonnegative-Flonum * -> Nonnegative-Flonum)
%(Float * -> Float)
%((U Zero One Byte-Larger-Than-One Positive-Index-Not-Byte Positive-Fixnum-Not-Index Positive-Integer-Not-Fixnum Float-Positive-Zero Positive-Flonum) * -> Nonnegative-Flonum)
%(Float Real * -> Float)
%(Real Float Real * -> Float)
%(Inexact-Real * -> Inexact-Real)
%(Real * -> Real)
%((U Zero One Byte-Larger-Than-One Positive-Index-Not-Byte
%    Positive-Fixnum-Not-Index Negative-Fixnum-Not-Index
%    Positive-Integer-Not-Fixnum Negative-Integer-Not-Fixnum
%    Positive-Rational-Not-Integer Negative-Rational-Not-Integer
%    Float-Positive-Zero Float-Negative-Zero Float-Nan
%    Positive-Flonum Negative-Float Single-Flonum-Positive-Zero
%    Single-Flonum-Negative

\subsection*{Local Type Inference}
Typed Racket's use of local type inference also leads to spurious type
errors, especially in the presence of precise types for Racket's numeric
hierarchy. For example, Typed Racket distinguishes integers from
positive integers, leading to a type error in the following expression:
\begin{center}
  \scheme|(vector-append (vector -1 2) (vector 1 2))|
\end{center}

\noindent
since the first vector and second vector have the type \scheme|(Vectorof
Exact-Positive-Integer)| and \scheme|(Vectorof Integer)| respectively,
neither of which is a subtype of the other. Because of this problem,
Typed Racket throws the error shown in Figure~\ref{er:2}.

\begin{figure*}
\begin{plain}
  \begin{schemedisplay}
Type Checker: Polymorphic function vector-append could not be applied to arguments:
Domain: (Vectorof a) *
Arguments: (Vectorof Exact-Positive-Integer) (Vectorof Integer)
  \end{schemedisplay}
\end{plain}
\caption{Type Error: \emph{vector-append}}
\label{er:2}
\end{figure*}

\noindent
Working around this requires manual annotation to ensure that both
vectors have element type \scheme|Integer|.

%, as seen in the examples in \ref{fds}.


%@;{item{Even though Typed Racket test engine is pretty good, there are couple 
%        of draw backs in it. For example,
%        @schememod[typed/scheme
%                   (require "bankers-queue.ss")
%                   (require typed/test-engine/scheme-tests)
%                   (check-expect (tail (queue 1 2 3))
%                                 (queue 2 3))]
%        @para{The above test fails saying that the two given queues are
%              different even though the contents of the queues are same. In
%              order to get around with this limitation of the test engine and
%              test the programs, for each data structure, we had to implement a
%              function which converts the data structure into a list. For
%              example, all queue data structures have the function
%              @scheme[queue->list].}}}
